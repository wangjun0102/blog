---
layout: post
title: Java多线程 - synchronized
date:   2016-5-25
categories: "java多线程"
tags: [java, jvm]
author: Mark
comment: false
---

> 在Java中，使用synchronized关键字是最基本的互斥同步手段，synchronized可用于普通方法，静态方法，代码块，分别锁的是当前实例对象，当前类的class对象和括号中的实例对象，底层实现方法除了细节差异外基本一致，都是使用监视器monitor。

首先使用javap查看下面代码的class文件信息：

``` javas
public class Test{
	public void test(){
		synchronized (this){
			System.out.println("Hello");
		}
	}
}
```
javap –c Test，反汇编信息如下图：

![ ][1]  <br>
　　上图第一处红框中执行monitorenter指令，尝试获取对象的锁，如果对象没有被锁定，或者当前线程已经拥有该对象的锁，把锁的计算器加1。相应的，第二处红框中在执行monitorexit指令时会将锁计数器减1，当计算器为0时，锁就被释放。JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。这里需要有两点需要注意：<br>

　　1. synchronized同步块对同一个线程来说可以重入；<br> 
　　2. 同步块在已进入的线程执行完之前，会阻塞后面其他线程进入；<br>

　　上述monitorenter和monitorexit字节码依赖于底层的操作系统来实现的，阻塞或者唤醒一个线程也需要依赖操作系统，这就需要从用户态切换到内核态来执行，十分的消耗CPU时间，这可能比执行用户代码的时间更长，所以synchronized是java中一个重量级（HeavyWeight）的操作。而在JDK1.6中针对synchronized锁做了大量优化，下面做下简单介绍：
#### 自旋锁
　　频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。很多时候，对象锁状态只会持续很短时间，为了这段很短的时间挂起和恢复线程并不值得，因此引入了自旋锁。所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。如何等待？我们只需让线程执行一段忙循环（自旋）即可。JDK1.6之后，默认开启自旋锁，自旋次数默认为10次，可以通过参数-XX:preBlockSpin来调整。<br>
　　然而自旋等待不能代替阻塞，虽然避免了线程切换的开销，但无意义的循环也要占用处理器时间。这要取决于锁被占用的时间，如果时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间较长，自旋结束不久就释放锁，或者还未释放，那只会白白消耗处理器资源，带来性能的浪费，于是又引入了自适应自旋锁。

#### 自适应自旋
　　自适应自旋意味着自旋时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要获得这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

#### 锁消除
　　锁消除是指对某些操作进行同步后 ，但被JVM检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。如果一段代码中，堆上所有数据都不会逃逸出去被其他线程访问，那就可以把他们当作栈上数据对待，认为它们是线程私有的，就无需加锁。变量是否逃逸不仅仅取决于我们自己代码中有没有显示使用锁，还有在使用JDK API时候也会存在隐形加锁操作，比如：HashTable、Vector、StringBuffer等，如果JVM明显检测出变量没有逃逸出方法之外，会安全的消除锁。
上面说到逃逸，这里用一段代码简单说下，

#### 锁粗化
　　原则上使用同步锁的时候，需要让同步块的作用范围尽可能小（仅在共享数据的实际作用域中才进行同步），这样做为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 但如果一系列连续操作对同一个对象反复加锁、解锁，比如在循环体中加锁，这样势必带来性能的损耗。可以考虑更大范围的同步操作，即把加锁、解锁操作移到循环外。

		
#### 轻量级锁
　　引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，而不是用来代替重量级锁。介绍轻量级锁之前，先简单介绍下虚拟机对象头（Object Head）。synchronized用的锁也是存在Java对象头里的，对象头主要包含两部分数据：<br>

 1. Mark Word（标记字段），用于存对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志等。 <br>
 2. Klass Pointer（类型指针），用户村粗指向方法区对象类型数据的指针。<br>

##### 对象头结构为：

　　Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间。内容见下表（摘自《深入理解java虚拟机》）：

|  存储内容   |   标志位  |   状态  |
| --- | --- | --- |
| 对象哈希码、分代年龄 |   01  |   未锁定  |
| 指向锁记录的指针    |   00  |    轻量级锁定 |
|    指向重量级锁的指针 |  10   |  重量级锁定   |
|   偏向线程ID、偏向时间戳、对象分代年龄  |  01   |  可偏向   |

　　**再回到轻量级锁上来，说下轻量锁获取锁（moniterenter）的过程为：**

　　1. 判断表中哈希码是否为01，即当前对象是否处于无锁状态，若是，JVM将在当前线程的栈帧中建立一个名为锁记录（Lock  Record）的空间，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word）；<br>
　　2. 利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表中第二行，指向锁记录的指针），处于轻量级锁状态；<br>
　　3. 如果失败，判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则说明该锁对象已经被其他线程抢占，这时轻量级锁需要转为重量级锁，锁标志位变成10（表中第三行，指向重量级锁的指针）；<br>

　　**释放锁（monitorexit）过程为：**

　　1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据；<br>
　　2. 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功；<br>
　　3. 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。<br>

　　轻量级锁提升性能是在没有竞争的条件下，CAS避免使用互斥带来的开销，如果存在竞争，则会比重量级锁多了CAS操作，只会更慢。<br><br>
　　上述涉及的CAS，什么是CAS？在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。UnSafe中有CAS相关实现，JUC下的atomic类都是通过CAS来实现的，更详细的介绍麻烦自行去了解。

#### 偏向锁
　　偏向锁是在无竞争的情况下把整个同步消除掉，当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位（表中第五行，偏向线程ID…）设为 “01”，即偏向模型。同时使用CAS操作把获取到这个锁的线程ID记录在对象Mark Word中，成功则持有偏向锁，以后进这个锁相关的同步块不再进行任何同步操作。如果有另外一个线程尝试获取这个锁，偏向模式结束，恢复到为锁定或轻量级锁状态，后续操作同轻量级锁。<br>
		可以看出偏向锁不一定有利，如果程序中大多数锁被多个不同线程访问，可以关闭偏向锁优化。

#### 总结
　　简单介绍了synchronized的实现及jdk对此做的优化（自旋，自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁），由于文笔拙劣，写的条理不是很清晰，希望大家将就看完后，有个大致的了解，需要深入的自行研究，谢谢。<br>

　　参考：周志明 《深入理解java虚拟机》

  

  [1]: http://wx3.sinaimg.cn/mw690/907499d8gy1fjh3dstq72j20hs0fdwen.jpg