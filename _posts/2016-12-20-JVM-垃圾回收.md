---
layout: post
title: JVM-垃圾回收
date:   2016-5-30
categories: "JVM"
tags: [java, jvm]
author: Mark
comment: false
---

> Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但是也增加了软件系统的负担。

## 对象已死？
> 在堆里面存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是确定这些对象之中哪些还“存活”着，哪些已经“死去”。

#### 引用计算法（Reference Counting）
　　引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。具体实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。

#### 可达性分析算法（Reachability Analysis）
　　可达性算法基本思路是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br />
　　**在java语言中，可作为GC Roots的对象包括下面几种：**
  
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常量引用的对象
 - 本地方法栈中JNI（Native方法）引用的对象
 
#### 再谈引用
　　有时候存在一些“食之无味弃之可惜”的对象，我们希望这样描述这些对象，在系统内存足够的情况下，保留这些对象；如果内存空间在垃圾回收之后依然十分紧张，则可以抛弃这些对象。<br />
　　**java中对引用的概念进行了扩充，将引用分为：**
  
 - 强引用：系统中普遍存在，类似Object o = new Object()，这类对象只要存在引用，垃圾回收器永远不会回收掉被引用的对象。
 - 软引用：描述一些还有用但非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存一出异常。JDK中提供SoftReference类来实现软引用。
 - 弱引用：描述一些非必需的对象。它的强度比软引用要弱一些，被弱引用关联的对象只能存活到下一次GC之前。当垃圾收集器工作时，无论内存是否足够，都会回收到弱引用关联的对象。JDK中提供WeakReference类来实现弱引用。
 - 虚引用：为对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK提供PhantomReference类来实现虚引用。

## 垃圾收集算法
> 简单介绍几种算法的思想

#### 标记-清除（Mark-Sweep）
　　标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的两个==问题==是：
  
1. 效率问题，标记和清除两个阶段效率都不高；
2. 存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间；
  
  

