---
layout: post
title: JVM-垃圾回收
date:   2016-5-30
categories: "JVM"
tags: [java, jvm]
author: Mark
comment: false
---

> Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但是也增加了软件系统的负担。

## 对象已死？
> 在堆里面存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是确定这些对象之中哪些还“存活”着，哪些已经“死去”。

#### 引用计算法（Reference Counting）
　　引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。具体实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。

#### 可达性分析算法（Reachability Analysis）
　　可达性算法基本思路是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br />
　　**在java语言中，可作为GC Roots的对象包括下面几种：**
  
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常量引用的对象
 - 本地方法栈中JNI（Native方法）引用的对象
 
#### 再谈引用
　　有时候存在一些“食之无味弃之可惜”的对象，我们希望这样描述这些对象，在系统内存足够的情况下，保留这些对象；如果内存空间在垃圾回收之后依然十分紧张，则可以抛弃这些对象。<br />
　　**java中对引用的概念进行了扩充，将引用分为：**
  
 - 强引用：系统中普遍存在，类似Object o = new Object()，这类对象只要存在引用，垃圾回收器永远不会回收掉被引用的对象。
 - 软引用：描述一些还有用但非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存一出异常。JDK中提供SoftReference类来实现软引用。
 - 弱引用：描述一些非必需的对象。它的强度比软引用要弱一些，被弱引用关联的对象只能存活到下一次GC之前。当垃圾收集器工作时，无论内存是否足够，都会回收到弱引用关联的对象。JDK中提供WeakReference类来实现弱引用。
 - 虚引用：为对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK提供PhantomReference类来实现虚引用。

## 垃圾收集算法
> 简单介绍几种算法的思想

#### 标记-清除（Mark-Sweep）
　　标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的两个问题是：
  
1. 效率问题，标记和清除两个阶段效率都不高；
2. 存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间；

#### 复制（Copy）
　　将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。<br />
　　Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分，比例为 8：1：1 。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。
  
#### 标记-压缩 （Mark-Compact）
　　复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。<br />
　　标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
  

#### 分代收集
　　新生代使用复制算法，对象几乎都是朝生夕死，老年代使用标记-清除 或者 标记-压缩算法。
  
  